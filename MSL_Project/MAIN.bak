//****************************************************************************
// @Module        Project Settings
// @Filename      MAIN.C
// @Project       DAvE_config.dav
//----------------------------------------------------------------------------
// @Controller    Infineon XE167F-96F66
//
// @Compiler      Tasking Classic
//
// @Codegenerator 2.2
//
// @Description   This file contains the project initialization function.
//
//----------------------------------------------------------------------------
// @Date          27.09.2021 18:18:18
//
//****************************************************************************

// USER CODE BEGIN (MAIN_General,1)

// USER CODE END



//****************************************************************************
// @Project Includes
//****************************************************************************

#include "MAIN.H"

// USER CODE BEGIN (MAIN_General,2)
#include <math.h>
// USER CODE END


//****************************************************************************
// @Macros
//****************************************************************************

// USER CODE BEGIN (MAIN_General,3)

// USER CODE END


//****************************************************************************
// @Defines
//****************************************************************************

// USER CODE BEGIN (MAIN_General,4)
	// clockwise=rechtslauf, counterclockwise=linkslauf
  	#define clockwise (0)
  	#define counterclockwise (1)
// USER CODE END


//****************************************************************************
// @Typedefs
//****************************************************************************

// USER CODE BEGIN (MAIN_General,5)

// USER CODE END


//****************************************************************************
// @Imported Global Variables
//****************************************************************************

// USER CODE BEGIN (MAIN_General,6)

// USER CODE END


//****************************************************************************
// @Global Variables
//****************************************************************************

// USER CODE BEGIN (MAIN_General,7)
	unsigned int frequency = 0;
	const unsigned int ARRAY_SIZE = 1200;
	unsigned int OFFSET_L1;
	unsigned int OFFSET_L2;
	unsigned int OFFSET_L3;
	unsigned int table[ARRAY_SIZE];
	unsigned int index;
	float pi = 3.14159265359;
	volatile unsigned int rampIndex;
   
	//unsigned int ccu62_pr = 1/(frequency * ARRAY_SIZE*0.000000015);

// USER CODE END


//****************************************************************************
// @External Prototypes
//****************************************************************************

// USER CODE BEGIN (MAIN_General,8)

// USER CODE END


//****************************************************************************
// @Prototypes Of Local Functions
//****************************************************************************

// USER CODE BEGIN (MAIN_General,9)
void generateTable();
unsigned int calculateMotorFrequency (int frequency);
void setPhaseChange(int dir);
// USER CODE END


//****************************************************************************
// @Function      void MAIN_vInit(void) 
//
//----------------------------------------------------------------------------
// @Description   This function initializes the microcontroller.
//
//----------------------------------------------------------------------------
// @Returnvalue   None
//
//----------------------------------------------------------------------------
// @Parameters    None
//
//----------------------------------------------------------------------------
// @Date          27.09.2021
//
//****************************************************************************

// USER CODE BEGIN (Init,1)

// USER CODE END

void MAIN_vInit(void)
{
  // USER CODE BEGIN (Init,2)

  // USER CODE END

  //   globally disable interrupts
  PSW_IEN        =  0;          


  ///  -----------------------------------------------------------------------
  ///  Configuration of the System Clock:
  ///  -----------------------------------------------------------------------
  ///  - VCO clock used, input clock is connected
  ///  - input frequency is 10,00 MHz
  ///  - configured system frequency is 66,00 MHz

  MAIN_vUnlockProtecReg();     // unlock write security

  MAIN_vChangeFreq();          // load PLL control register

  //   -----------------------------------------------------------------------
  //   Initialization of the Peripherals:
  //   -----------------------------------------------------------------------

  //   initializes the Parallel Ports
  IO_vInit();

  //   initializes the General Purpose Timer Unit (GPT1)
  GPT1_vInit();

  //   initializes the General Purpose Timer Unit (GPT2)
  GPT2_vInit();

  //   initializes the Capture / Compare Unit 2 (CAPCOM2)
  CC2_vInit();

  //   initializes the Capture / Compare Unit 62 (CCU62)
  CCU62_vInit();

  //   initializes the Capture / Compare Unit 63 (CCU63)
  CCU63_vInit();

  //   initializes the Analog / Digital Converter  (ADC0)
  ADC0_vInit();


  //   -----------------------------------------------------------------------
  //   Initialization of the Bank Select registers:
  //   -----------------------------------------------------------------------


  // USER CODE BEGIN (Init,3)

  // USER CODE END

  MAIN_vLockProtecReg();       // lock write security

  //   globally enable interrupts
  PSW_IEN        =  1;          

} //  End of function MAIN_vInit


//****************************************************************************
// @Function      void MAIN_vUnlockProtecReg(void) 
//
//----------------------------------------------------------------------------
// @Description   This function makes it possible to write one protected 
//                register.
//
//----------------------------------------------------------------------------
// @Returnvalue   None
//
//----------------------------------------------------------------------------
// @Parameters    None
//
//----------------------------------------------------------------------------
// @Date          27.09.2021
//
//****************************************************************************

// USER CODE BEGIN (UnlockProtecReg,1)

// USER CODE END

void MAIN_vUnlockProtecReg(void)
{
  uword uwPASSWORD;

    SCU_SLC = 0xAAAA;                   // command 0
    SCU_SLC = 0x5554;                   // command 1

    uwPASSWORD = SCU_SLS & 0x00FF;
    uwPASSWORD = (~uwPASSWORD) & 0x00FF;

    SCU_SLC = 0x9600 | uwPASSWORD;      // command 2
    SCU_SLC = 0x0000;                   // command 3

} //  End of function MAIN_vUnlockProtecReg


//****************************************************************************
// @Function      void MAIN_vLockProtecReg(void) 
//
//----------------------------------------------------------------------------
// @Description   This function makes it possible to lock one protected 
//                register.
//
//----------------------------------------------------------------------------
// @Returnvalue   None
//
//----------------------------------------------------------------------------
// @Parameters    None
//
//----------------------------------------------------------------------------
// @Date          27.09.2021
//
//****************************************************************************

// USER CODE BEGIN (LockProtecReg,1)

// USER CODE END

void MAIN_vLockProtecReg(void)
{
  uword uwPASSWORD;

    SCU_SLC = 0xAAAA;                   // command 0
    SCU_SLC = 0x5554;                   // command 1

    uwPASSWORD = SCU_SLS & 0x00FF;
    uwPASSWORD = (~uwPASSWORD) & 0x00FF;

    SCU_SLC = 0x9600 | uwPASSWORD;      // command 2
    SCU_SLC = 0x1800;                   // command 3; new PASSWOR is 0x00

    uwPASSWORD = SCU_SLS & 0x00FF;
    uwPASSWORD = (~uwPASSWORD) & 0x00FF;
    SCU_SLC = 0x8E00 | uwPASSWORD;      // command 4

} //  End of function MAIN_vLockProtecReg


//****************************************************************************
// @Function      void MAIN_vChangeFreq(void) 
//
//----------------------------------------------------------------------------
// @Description   This function is used to select the external crystal and
//                configure the system frequency to 80Mhz/66Mhz.
//
//----------------------------------------------------------------------------
// @Returnvalue   None
//
//----------------------------------------------------------------------------
// @Parameters    None
//
//----------------------------------------------------------------------------
// @Date          27.09.2021
//
//****************************************************************************

// USER CODE BEGIN (ChangeFreq,1)

// USER CODE END

void MAIN_vChangeFreq(void)
{
  SCS_SwitchToHighPrecBandgap();

  //For application and internal application resets, the complete PLL configuration could be avoided
  //The entry from application resets and internal application reset is covered in the following differentiation
  //in int/ext clock in lock/unlocked state.

  if  ((SCU_PLLSTAT & 0x0004) == 0x0004)             // fR derived from Internal clock
        {
            //Normal startup state during boot and the clock
            //has to be in the next step configured on the external crystal
            //use XTAL/VCO, count XTAL clock

            SCS_StartXtalOsc(1);                     // Starts the crystal oscillator
            SCS_SwitchSystemClock(1);                // System clock is increased to target speed (80/66 MHz)

        }

  else                                               // fR derived from external crystal clock
        {
            if ((SCU_PLLSTAT & 0x1009) == 0x1009)    // fR derived from external crystal clock + VCO is locked
            {
               //usually after an application reset where clock need not be configured again.
               //check K2/P/N values and decide whether these values have to be adapted based on application needs.
               NOP();
               //usually the PLL losss of Lock TRAP schould be enabled here.
            }
            else                                     //fR derived from external crystal clock + VCO is not locked

            {
               //estimate the K1 value and the current frequency
               //reduce K2/P/N values in steps so that the frequency
               //jumps is limited to 20MHz or factor of 5 whichever is minimum
               NOP();
            }


        }

} //  End of function MAIN_vChangeFreq


//****************************************************************************
// @Function      void main(void) 
//
//----------------------------------------------------------------------------
// @Description   This is the main function.
//
//----------------------------------------------------------------------------
// @Returnvalue   None
//
//----------------------------------------------------------------------------
// @Parameters    None
//
//----------------------------------------------------------------------------
// @Date          27.09.2021
//
//****************************************************************************

// USER CODE BEGIN (Main,1)

// USER CODE END

void main(void)
{
  // USER CODE BEGIN (Main,2)

  // USER CODE END

  MAIN_vInit();

  // USER CODE BEGIN (Main,3)
 	generateTable();
	ADC0_vInit();
	ADC0_vStartSeq0ReqChNum(0,0,1,6);
	CCU63_vStartTmr(CCU63_TIMER_12);
	CCU62_vStartTmr(CCU62_TIMER_12);
	GPT2_vStartTmr(GPT2_TIMER_6);
    // USER CODE END

  while(1)
  {

   // USER CODE BEGIN (Main,4)
   if (rampIndex > 350){
   		unsigned long raw;
		raw = ADC0_uwGetResultData(RESULT_REG_0);
		frequency = ((50*raw)/4096);
	   	CCU62_vSetTmrPeriod(CCU62_TIMER_12, calculateMotorFrequency(frequency));
		CCU62_vEnableShadowTransfer(CCU62_TIMER_12);
	}
	if (rampIndex == 0){
		setPhaseChange(clockwise);
	}
	if(rampIndex < 50){
		frequency = rampIndex;
		CCU62_vSetTmrPeriod(CCU62_TIMER_12, calculateMotorFrequency(frequency));
		CCU62_vEnableShadowTransfer(CCU62_TIMER_12);
		IO_vTogglePin(LED_DBG);
	} 
	
	if(rampIndex < 100 && rampIndex > 50){
		frequency = 50;
		CCU62_vSetTmrPeriod(CCU62_TIMER_12, calculateMotorFrequency(frequency));
		CCU62_vEnableShadowTransfer(CCU62_TIMER_12);
	}

	if(rampIndex < 150 && rampIndex > 100){
		frequency = (150 - rampIndex);
		CCU62_vSetTmrPeriod(CCU62_TIMER_12, calculateMotorFrequency(frequency));
		CCU62_vEnableShadowTransfer(CCU62_TIMER_12);
	}
	if (rampIndex == 151){
		setPhaseChange(counterclockwise);
	}
	if(rampIndex < 200 && rampIndex > 151){
		frequency = (rampIndex-150);
		CCU62_vSetTmrPeriod(CCU62_TIMER_12, calculateMotorFrequency(frequency));
		CCU62_vEnableShadowTransfer(CCU62_TIMER_12);
	}
	if(rampIndex < 250 && rampIndex > 200){
		frequency = 50;
		CCU62_vSetTmrPeriod(CCU62_TIMER_12, calculateMotorFrequency(frequency));
		CCU62_vEnableShadowTransfer(CCU62_TIMER_12);
	}
	if(rampIndex < 300 && rampIndex > 250){
		frequency = (300 - rampIndex);
		CCU62_vSetTmrPeriod(CCU62_TIMER_12, calculateMotorFrequency(frequency));
		CCU62_vEnableShadowTransfer(CCU62_TIMER_12);
	}
	if(rampIndex < 350 && rampIndex > 300){
		CCU62_vSetTmrPeriod(CCU62_TIMER_12, calculateMotorFrequency(50));
		CCU62_vEnableShadowTransfer(CCU62_TIMER_12);
	}


   // USER CODE END

  }

} //  End of function main



// USER CODE BEGIN (MAIN_General,10)
void generateTable(){
	double stepSize = (2*pi)/(ARRAY_SIZE);
	int i;
	for (i = 0; i < ARRAY_SIZE; i++){ 
		table[i] = (unsigned int)((double)((CCU63_T12PR - 140)/2)*sin(stepSize * i) + (CCU63_T12PR/2));
	}
}

unsigned int calculateMotorFrequency (int _frequency){
	if (_frequency < 2){
		frequency = 1;
		return (0xD903);
	}
	else {
		return (1/(_frequency * ARRAY_SIZE*0.000000015));
	}
}

void setPhaseChange(int dir){
	if(dir == clockwise){
		OFFSET_L1 = 0;
		OFFSET_L2 = (2*ARRAY_SIZE)/3;
		OFFSET_L3 = ARRAY_SIZE/3;
	}
	if(dir == counterclockwise){
		OFFSET_L1 = 0;
		OFFSET_L2 = ARRAY_SIZE/3;
		OFFSET_L3 = (2*ARRAY_SIZE)/3;
	}  
}


// USER CODE END

