; TASKING C166/ST10 C compiler v8.7r1 Build 775
; options: -e -Id:\programme\tasking\c166 v8.7r1\include -x2 -Bhoeufmknladij -OB
;          -OE -zswitch_tabmem_default -zautobitastruct-4 -zautobita-0 -FSC -A1
;          -zvolatile_union -O0 -g -newerr -s -i0 -Ms
$DEBUG
$NOLOCALS
$EXTEND2
$NOMOD166
$STDNAMES(regsuper10bo.def)
$EXTMAC
$CASE
$NOEXPANDREGBANK
$MODEL(SMALL)
	NAME	MAIN_C
	?SYMB	'main.c',32,80,16
	?SYMB	'',1,82,0
	?SYMB	'80166',0,84,0
	?SYMB	'',0,81,0
	?SYMB	'void',00H,45,1
	?SYMB	'char',080000H,45,2
	?SYMB	'unsigned char',080000H,45,3
	?SYMB	'short',0100000H,45,4
	?SYMB	'unsigned short',0100000H,45,5
	?SYMB	'long',0200000H,45,6
	?SYMB	'unsigned long',0200000H,45,7
	?SYMB	'float',0200000H,45,10
	?SYMB	'double',0400000H,45,11
	?SYMB	'int',0100000H,45,16
	?SYMB	'unsigned int',0100000H,45,18
	?SYMB	'bit',010000H,7,256
	?SYMB	'main.c',0,29,1
	?SYMB	'',0,86,1
; main.c      1	//****************************************************************************
; main.c      2	// @Module        Project Settings
; main.c      3	// @Filename      MAIN.C
; main.c      4	// @Project       DAvE_config.dav
; main.c      5	//----------------------------------------------------------------------------
; main.c      6	// @Controller    Infineon XE167F-96F66
; main.c      7	//
; main.c      8	// @Compiler      Tasking Classic
; main.c      9	//
; main.c     10	// @Codegenerator 2.2
; main.c     11	//
; main.c     12	// @Description   This file contains the project initialization function.
; main.c     13	//
; main.c     14	//----------------------------------------------------------------------------
; main.c     15	// @Date          29.09.2021 09:41:08
; main.c     16	//
; main.c     17	//****************************************************************************
; main.c     18	
; main.c     19	// USER CODE BEGIN (MAIN_General,1)
; main.c     20	
; main.c     21	// USER CODE END
; main.c     22	
; main.c     23	//****************************************************************************
; main.c     24	// @Project Includes
; main.c     25	//****************************************************************************
; main.c     26	
; main.c     27	#include "MAIN.H"
	?SYMB	'MAIN.H',0,29,2
	?SYMB	'',0,86,2
	?SYMB	'XE16xREGS.H',0,29,3
	?SYMB	'',0,86,3
	?SYMB	'',0,86,2
	?SYMB	'SCS.H',0,29,3
	?SYMB	'',0,86,3
	?SYMB	'T$2',0,14,257
	?SYMB	'SCS_EXTCLK_F_SYS',0,33,257
	?SYMB	'SCS_EXTCLK_F_OUT',1,33,257
	?SYMB	'SCS_EXTCLK_F_PLL',2,33,257
	?SYMB	'SCS_EXTCLK_F_OSC',3,33,257
	?SYMB	'SCS_EXTCLK_F_WU',4,33,257
	?SYMB	'SCS_EXTCLK_F_TCK',5,33,257
	?SYMB	'SCS_EXTCLK_F_OSC_FL',6,33,257
	?SYMB	'SCS_EXTCLK_F_RTC',8,33,257
	?SYMB	'',16,16,0
	?SYMB	'SCS_EXTCLK_Type',257,13,258
	?SYMB	'',0,86,2
	?SYMB	'IO.H',0,29,3
	?SYMB	'',0,86,3
	?SYMB	'',0,86,2
	?SYMB	'GPT1.H',0,29,3
	?SYMB	'',0,86,3
	?SYMB	'',0,86,2
	?SYMB	'GPT2.H',0,29,3
	?SYMB	'',0,86,3
	?SYMB	'',0,86,2
	?SYMB	'CCU62.H',0,29,3
	?SYMB	'',0,86,3
	?SYMB	'',0,86,2
	?SYMB	'CCU63.H',0,29,3
	?SYMB	'',0,86,3
	?SYMB	'',0,86,2
	?SYMB	'ADC0.H',0,29,3
	?SYMB	'',0,86,3
	?SYMB	'ubyte',3,13,259
	?SYMB	'',0,86,2
	?SYMB	'',0,86,1
; main.c     28	
; main.c     29	// USER CODE BEGIN (MAIN_General,2)
; main.c     30	#include <math.h>
	?SYMB	'd:\programme\tasking\c166 v8.7r1\include\math.h',0,29,2
	?SYMB	'',0,86,2
	?SYMB	'',0,86,1
; main.c     31	// USER CODE END
; main.c     32	
; main.c     33	//****************************************************************************
; main.c     34	// @Macros
; main.c     35	//****************************************************************************
; main.c     36	
; main.c     37	// USER CODE BEGIN (MAIN_General,3)
; main.c     38	
; main.c     39	// USER CODE END
; main.c     40	
; main.c     41	//****************************************************************************
; main.c     42	// @Defines
; main.c     43	//****************************************************************************
; main.c     44	
; main.c     45	// USER CODE BEGIN (MAIN_General,4)
; main.c     46	// clockwise=rechtslauf, counterclockwise=linkslauf definition einer Präprozessorvariable
; main.c     47	#define clockwise (0)
; main.c     48	#define counterclockwise (1)
; main.c     49	// USER CODE END
; main.c     50	
; main.c     51	//****************************************************************************
; main.c     52	// @Typedefs
; main.c     53	//****************************************************************************
; main.c     54	
; main.c     55	// USER CODE BEGIN (MAIN_General,5)
; main.c     56	
; main.c     57	// USER CODE END
; main.c     58	
; main.c     59	//****************************************************************************
; main.c     60	// @Imported Global Variables
; main.c     61	//****************************************************************************
; main.c     62	
; main.c     63	// USER CODE BEGIN (MAIN_General,6)
; main.c     64	
; main.c     65	// USER CODE END
; main.c     66	
; main.c     67	//****************************************************************************
; main.c     68	// @Global Variables
; main.c     69	//****************************************************************************
; main.c     70	
; main.c     71	// USER CODE BEGIN (MAIN_General,7)
; main.c     72	// Frequenz des Drehfeldes in Hz
; main.c     73	unsigned int frequency = 0;
MAIN_IR_NB	SECTION	PDAT WORD PUBLIC 'CINITROM'
MAIN_IR_NB_ENTRY	LABEL	BYTE
	DW	00h
MAIN_IR_NB	ENDS

MAIN_ID_NB	SECTION	LDAT WORD PUBLIC 'CINITIRAM'
MAIN_ID_NB_ENTRY	LABEL	BYTE
_frequency	LABEL	WORD
	DS	2
	PUBLIC	_frequency
	?SYMB	'frequency',_frequency,22,18
; main.c     74	// Größe der Sinus Wertetabelle
; main.c     75	const unsigned int ARRAY_SIZE = 1200;
MAIN_ID_NB	ENDS

MAIN_3_NC	SECTION	LDAT WORD PUBLIC 'CNEARROM'
_ARRAY_SIZE	LABEL	WORD
	DW	04B0h
	PUBLIC	_ARRAY_SIZE
	?SYMB	'ARRAY_SIZE',_ARRAY_SIZE,22,18
; main.c     76	// Phasenverschiebung
; main.c     77	unsigned int OFFSET_L1;
; main.c     78	unsigned int OFFSET_L2;
; main.c     79	unsigned int OFFSET_L3;
; main.c     80	// Wertetabelle des Sinus
; main.c     81	int table[ARRAY_SIZE];
; main.c     82	// Index der Wertetabelle
; main.c     83	unsigned int index;
; main.c     84	
; main.c     85	float pi = 3.14159265359;
MAIN_3_NC	ENDS

MAIN_IR_NB	SECTION	PDAT
	DW	04049h,0FDBh
MAIN_IR_NB	ENDS

MAIN_ID_NB	SECTION	LDAT
_pi	LABEL	WORD
	DS	4
	PUBLIC	_pi
	?SYMB	'pi',_pi,22,10
; main.c     86	// Index für die Rampensteuerung Erhöhung alle 8 ms
; main.c     87	volatile unsigned int rampIndex;
; main.c     88	// mechanische Geschwindigkeit des Motors in Hz
; main.c     89	volatile float velocity;
; main.c     90	// Integralsumme des I-Reglers
; main.c     91	int integral_sum;
; main.c     92	// Proportionalanteil P-Regler
; main.c     93	const float K_p = 0.05;
MAIN_ID_NB	ENDS

MAIN_3_NC	SECTION	LDAT
_K_p	LABEL	WORD
	DW	03D4Ch,0CCCDh
	PUBLIC	_K_p
	?SYMB	'K_p',_K_p,22,10
; main.c     94	// Integrealanteil I-Rgler
; main.c     95	const float K_i = 0.01;
_K_i	LABEL	WORD
	DW	03C23h,0D70Ah
	PUBLIC	_K_i
	?SYMB	'K_i',_K_i,22,10
; main.c     96	// Verschiebung des Gleichanteils des Sinus
; main.c     97	const unsigned int HALF_PERIODVALUE = 901;
_HALF_PERIODVALUE	LABEL	WORD
	DW	0385h
	PUBLIC	_HALF_PERIODVALUE
	?SYMB	'HALF_PERIODVALUE',_HALF_PERIODVALUE,22,18
; main.c     98	// USER CODE END
; main.c     99	
; main.c    100	//****************************************************************************
; main.c    101	// @External Prototypes
; main.c    102	//****************************************************************************
; main.c    103	
; main.c    104	// USER CODE BEGIN (MAIN_General,8)
; main.c    105	
; main.c    106	// USER CODE END
; main.c    107	
; main.c    108	//****************************************************************************
; main.c    109	// @Prototypes Of Local Functions
; main.c    110	//****************************************************************************
; main.c    111	
; main.c    112	// USER CODE BEGIN (MAIN_General,9)
; main.c    113	// Funktion zur Generierung der Sinus Wertetabelle
; main.c    114	void generateTable();
; main.c    115	// Funktion zur Berechnung des CCU62 Period Value Registers in Abhängigkeit der Frequenz
; main.c    116	unsigned int calculateMotorFrequency(unsigned int _frequency);
; main.c    117	// Setzen der Phasenverschiebung für Links- und Rechtslauf, 0 = Rechtslauf 1 = Linkslauf
; main.c    118	void setPhaseChange(int dir);
; main.c    119	// Funktion für den PI-Regler, errechnet Stellgröße in Abhängigkeit der gemessenen Geschwindigkeit
; main.c    120	unsigned int controller(int input);
; main.c    121	// USER CODE END
; main.c    122	
; main.c    123	//****************************************************************************
; main.c    124	// @Function      void MAIN_vInit(void)
; main.c    125	//
; main.c    126	//----------------------------------------------------------------------------
; main.c    127	// @Description   This function initializes the microcontroller.
; main.c    128	//
; main.c    129	//----------------------------------------------------------------------------
; main.c    130	// @Returnvalue   None
; main.c    131	//
; main.c    132	//----------------------------------------------------------------------------
; main.c    133	// @Parameters    None
; main.c    134	//
; main.c    135	//----------------------------------------------------------------------------
; main.c    136	// @Date          29.09.2021
; main.c    137	//
; main.c    138	//****************************************************************************
; main.c    139	
; main.c    140	// USER CODE BEGIN (Init,1)
; main.c    141	
; main.c    142	// USER CODE END
; main.c    143	
; main.c    144	void MAIN_vInit(void) {
MAIN_3_NC	ENDS

MAIN_4_PR	SECTION	CODE WORD PUBLIC 'CPROGRAM'
	?LINE	144
	PUBLIC	_MAIN_vInit
	?SYMB	'MAIN_vInit',_MAIN_vInit,37,1
	?SYMB	'',144,8,34
	?SYMB	'',010000H,7,261
	?SYMB	'',010001H,7,262
	?SYMB	'',010002H,7,263
	?SYMB	'',010003H,7,264
	?SYMB	'',010004H,7,265
	?SYMB	'',010005H,7,266
	?SYMB	'',010006H,7,267
	?SYMB	'',010007H,7,268
	?SYMB	'',010000H,7,269
	?SYMB	'',010001H,7,270
	?SYMB	'',010002H,7,271
	?SYMB	'',010003H,7,272
	?SYMB	'',010004H,7,273
	?SYMB	'',010005H,7,274
	?SYMB	'',010006H,7,275
	?SYMB	'',010007H,7,276
	?SYMB	'T$1',0,40,277
	?SYMB	'bit0',0,23,261
	?SYMB	'bit1',1,23,262
	?SYMB	'bit2',2,23,263
	?SYMB	'bit3',3,23,264
	?SYMB	'bit4',4,23,265
	?SYMB	'bit5',5,23,266
	?SYMB	'bit6',6,23,267
	?SYMB	'bit7',7,23,268
	?SYMB	'bit8',8,23,269
	?SYMB	'bit9',9,23,270
	?SYMB	'bit10',10,23,271
	?SYMB	'bit11',11,23,272
	?SYMB	'bit12',12,23,273
	?SYMB	'bit13',13,23,274
	?SYMB	'bit14',14,23,275
	?SYMB	'bit15',15,23,276
	?SYMB	'',16,18,0
	?SYMB	'T_Reg16',277,13,278
_MAIN_vInit	PROC	FAR
	?SYMB	'',00H,95,0
; Locals:
; 
; Statics:
; 
; CSEs:
; 
; main.c    145		// USER CODE BEGIN (Init,2)
; main.c    146	
; main.c    147		// USER CODE END
; main.c    148	
; main.c    149		//   globally disable interrupts
; main.c    150		PSW_IEN = 0;
	?LINE	150
	MOV	R12,#0FF10h
	MOV	R13,[R12]
	AND	R13,#0F7FFh
	MOV	[R12],R13
; main.c    151	
; main.c    152		///  -----------------------------------------------------------------------
; main.c    153		///  Configuration of the System Clock:
; main.c    154		///  -----------------------------------------------------------------------
; main.c    155		///  - VCO clock used, input clock is connected
; main.c    156		///  - input frequency is 10,00 MHz
; main.c    157		///  - configured system frequency is 66,00 MHz
; main.c    158	
; main.c    159		MAIN_vUnlockProtecReg();  // unlock write security
	?LINE	159
	CALLS	SEG _MAIN_vUnlockProtecReg,_MAIN_vUnlockProtecReg
; main.c    160	
; main.c    161		MAIN_vChangeFreq();	 // load PLL control register
	?LINE	161
	CALLS	SEG _MAIN_vChangeFreq,_MAIN_vChangeFreq
; main.c    162	
; main.c    163		//   -----------------------------------------------------------------------
; main.c    164		//   Initialization of the Peripherals:
; main.c    165		//   -----------------------------------------------------------------------
; main.c    166	
; main.c    167		//   initializes the Parallel Ports
; main.c    168		IO_vInit();
	?LINE	168
	CALLS	SEG _IO_vInit,_IO_vInit
; main.c    169	
; main.c    170		//   initializes the General Purpose Timer Unit (GPT1)
; main.c    171		GPT1_vInit();
	?LINE	171
	CALLS	SEG _GPT1_vInit,_GPT1_vInit
; main.c    172	
; main.c    173		//   initializes the General Purpose Timer Unit (GPT2)
; main.c    174		GPT2_vInit();
	?LINE	174
	CALLS	SEG _GPT2_vInit,_GPT2_vInit
; main.c    175	
; main.c    176		//   initializes the Capture / Compare Unit 62 (CCU62)
; main.c    177		CCU62_vInit();
	?LINE	177
	CALLS	SEG _CCU62_vInit,_CCU62_vInit
; main.c    178	
; main.c    179		//   initializes the Capture / Compare Unit 63 (CCU63)
; main.c    180		CCU63_vInit();
	?LINE	180
	CALLS	SEG _CCU63_vInit,_CCU63_vInit
; main.c    181	
; main.c    182		//   initializes the Analog / Digital Converter  (ADC0)
; main.c    183		ADC0_vInit();
	?LINE	183
	CALLS	SEG _ADC0_vInit,_ADC0_vInit
; main.c    184	
; main.c    185		//   -----------------------------------------------------------------------
; main.c    186		//   Initialization of the Bank Select registers:
; main.c    187		//   -----------------------------------------------------------------------
; main.c    188	
; main.c    189		// USER CODE BEGIN (Init,3)
; main.c    190	
; main.c    191		// USER CODE END
; main.c    192	
; main.c    193		MAIN_vLockProtecReg();	// lock write security
	?LINE	193
	CALLS	SEG _MAIN_vLockProtecReg,_MAIN_vLockProtecReg
; main.c    194	
; main.c    195		//   globally enable interrupts
; main.c    196		PSW_IEN = 1;
	?LINE	196
	MOV	R12,#0FF10h
	MOV	R13,[R12]
	BFLDH	R13,#08h,#08h
	MOV	[R12],R13
; main.c    197	
; main.c    198	}  //  End of function MAIN_vInit
	?LINE	198
	RETS
_MAIN_vInit	ENDP
	?SYMB	'',$,17,198
; main.c    199	
; main.c    200	//****************************************************************************
; main.c    201	// @Function      void MAIN_vUnlockProtecReg(void)
; main.c    202	//
; main.c    203	//----------------------------------------------------------------------------
; main.c    204	// @Description   This function makes it possible to write one protected
; main.c    205	//                register.
; main.c    206	//
; main.c    207	//----------------------------------------------------------------------------
; main.c    208	// @Returnvalue   None
; main.c    209	//
; main.c    210	//----------------------------------------------------------------------------
; main.c    211	// @Parameters    None
; main.c    212	//
; main.c    213	//----------------------------------------------------------------------------
; main.c    214	// @Date          29.09.2021
; main.c    215	//
; main.c    216	//****************************************************************************
; main.c    217	
; main.c    218	// USER CODE BEGIN (UnlockProtecReg,1)
; main.c    219	
; main.c    220	// USER CODE END
; main.c    221	
; main.c    222	void MAIN_vUnlockProtecReg(void) {
	?LINE	222
	PUBLIC	_MAIN_vUnlockProtecReg
	?SYMB	'MAIN_vUnlockProtecReg',_MAIN_vUnlockProtecReg,37,1
	?SYMB	'',222,8,34
	?SYMB	'uword',18,13,280
_MAIN_vUnlockProtecReg	PROC	FAR
	?SYMB	'',00H,95,0
	SUB	R0,#02h
	?SYMB	'',$,96,2
; Locals:
;     uwPASSWORD = offset 0
; 
; Statics:
; 
; CSEs:
; 
; main.c    223		uword uwPASSWORD;
	?SYMB	'uwPASSWORD',1,98,280
	?SYMB	'-2',$,101,1
; main.c    224	
; main.c    225		SCU_SLC = 0xAAAA;  // command 0
	?LINE	225
	MOV	R12,#0AAAAh
	MOV	0F0C0h,R12
; main.c    226		SCU_SLC = 0x5554;  // command 1
	?LINE	226
	MOV	R12,#05554h
	MOV	0F0C0h,R12
; main.c    227	
; main.c    228		uwPASSWORD = SCU_SLS & 0x00FF;
	?LINE	228
	MOV	R12,0F0C2h
	AND	R12,#0FFh
	MOV	[R0],R12
; main.c    229		uwPASSWORD = (~uwPASSWORD) & 0x00FF;
	?LINE	229
	MOV	R12,[R0]
	CPL	R12
	AND	R12,#0FFh
	MOV	[R0],R12
; main.c    230	
; main.c    231		SCU_SLC = 0x9600 | uwPASSWORD;	// command 2
	?LINE	231
	MOV	R12,[R0]
	OR	R12,#09600h
	MOV	0F0C0h,R12
; main.c    232		SCU_SLC = 0x0000;				// command 3
	?LINE	232
	MOV	R12,#00h
	MOV	0F0C0h,R12
; main.c    233	
; main.c    234	}  //  End of function MAIN_vUnlockProtecReg
	?SYMB	'',$,102,1
	?LINE	234
	ADD	R0,#02h
	?SYMB	'',$,96,0
	RETS
_MAIN_vUnlockProtecReg	ENDP
	?SYMB	'',$,17,234
; main.c    235	
; main.c    236	//****************************************************************************
; main.c    237	// @Function      void MAIN_vLockProtecReg(void)
; main.c    238	//
; main.c    239	//----------------------------------------------------------------------------
; main.c    240	// @Description   This function makes it possible to lock one protected
; main.c    241	//                register.
; main.c    242	//
; main.c    243	//----------------------------------------------------------------------------
; main.c    244	// @Returnvalue   None
; main.c    245	//
; main.c    246	//----------------------------------------------------------------------------
; main.c    247	// @Parameters    None
; main.c    248	//
; main.c    249	//----------------------------------------------------------------------------
; main.c    250	// @Date          29.09.2021
; main.c    251	//
; main.c    252	//****************************************************************************
; main.c    253	
; main.c    254	// USER CODE BEGIN (LockProtecReg,1)
; main.c    255	
; main.c    256	// USER CODE END
; main.c    257	
; main.c    258	void MAIN_vLockProtecReg(void) {
	?LINE	258
	PUBLIC	_MAIN_vLockProtecReg
	?SYMB	'MAIN_vLockProtecReg',_MAIN_vLockProtecReg,37,1
	?SYMB	'',258,8,34
_MAIN_vLockProtecReg	PROC	FAR
	?SYMB	'',00H,95,0
	SUB	R0,#02h
	?SYMB	'',$,96,2
; Locals:
;     uwPASSWORD = offset 0
; 
; Statics:
; 
; CSEs:
; 
; main.c    259		uword uwPASSWORD;
	?SYMB	'uwPASSWORD',1,98,280
	?SYMB	'-2',$,101,1
; main.c    260	
; main.c    261		SCU_SLC = 0xAAAA;  // command 0
	?LINE	261
	MOV	R12,#0AAAAh
	MOV	0F0C0h,R12
; main.c    262		SCU_SLC = 0x5554;  // command 1
	?LINE	262
	MOV	R12,#05554h
	MOV	0F0C0h,R12
; main.c    263	
; main.c    264		uwPASSWORD = SCU_SLS & 0x00FF;
	?LINE	264
	MOV	R12,0F0C2h
	AND	R12,#0FFh
	MOV	[R0],R12
; main.c    265		uwPASSWORD = (~uwPASSWORD) & 0x00FF;
	?LINE	265
	MOV	R12,[R0]
	CPL	R12
	AND	R12,#0FFh
	MOV	[R0],R12
; main.c    266	
; main.c    267		SCU_SLC = 0x9600 | uwPASSWORD;	// command 2
	?LINE	267
	MOV	R12,[R0]
	OR	R12,#09600h
	MOV	0F0C0h,R12
; main.c    268		SCU_SLC = 0x1800;				// command 3; new PASSWOR is 0x00
	?LINE	268
	MOV	R12,#01800h
	MOV	0F0C0h,R12
; main.c    269	
; main.c    270		uwPASSWORD = SCU_SLS & 0x00FF;
	?LINE	270
	MOV	R12,0F0C2h
	AND	R12,#0FFh
	MOV	[R0],R12
; main.c    271		uwPASSWORD = (~uwPASSWORD) & 0x00FF;
	?LINE	271
	MOV	R12,[R0]
	CPL	R12
	AND	R12,#0FFh
	MOV	[R0],R12
; main.c    272		SCU_SLC = 0x8E00 | uwPASSWORD;	// command 4
	?LINE	272
	MOV	R12,[R0]
	OR	R12,#08E00h
	MOV	0F0C0h,R12
; main.c    273	
; main.c    274	}  //  End of function MAIN_vLockProtecReg
	?SYMB	'',$,102,1
	?LINE	274
	ADD	R0,#02h
	?SYMB	'',$,96,0
	RETS
_MAIN_vLockProtecReg	ENDP
	?SYMB	'',$,17,274
; main.c    275	
; main.c    276	//****************************************************************************
; main.c    277	// @Function      void MAIN_vChangeFreq(void)
; main.c    278	//
; main.c    279	//----------------------------------------------------------------------------
; main.c    280	// @Description   This function is used to select the external crystal and
; main.c    281	//                configure the system frequency to 80Mhz/66Mhz.
; main.c    282	//
; main.c    283	//----------------------------------------------------------------------------
; main.c    284	// @Returnvalue   None
; main.c    285	//
; main.c    286	//----------------------------------------------------------------------------
; main.c    287	// @Parameters    None
; main.c    288	//
; main.c    289	//----------------------------------------------------------------------------
; main.c    290	// @Date          29.09.2021
; main.c    291	//
; main.c    292	//****************************************************************************
; main.c    293	
; main.c    294	// USER CODE BEGIN (ChangeFreq,1)
; main.c    295	
; main.c    296	// USER CODE END
; main.c    297	
; main.c    298	void MAIN_vChangeFreq(void) {
	?LINE	298
	PUBLIC	_MAIN_vChangeFreq
	?SYMB	'MAIN_vChangeFreq',_MAIN_vChangeFreq,37,1
	?SYMB	'',298,8,34
_MAIN_vChangeFreq	PROC	FAR
	?SYMB	'',00H,95,0
; Locals:
; 
; Statics:
; 
; CSEs:
; 
; main.c    299		SCS_SwitchToHighPrecBandgap();
	?LINE	299
	CALLS	SEG _SCS_SwitchToHighPrecBandgap,_SCS_SwitchToHighPrecBandgap
; main.c    300	
; main.c    301		//For application and internal application resets, the complete PLL configuration could be avoided
; main.c    302		//The entry from application resets and internal application reset is covered in the following differentiation
; main.c    303		//in int/ext clock in lock/unlocked state.
; main.c    304	
; main.c    305		if ((SCU_PLLSTAT & 0x0004) == 0x0004)  // fR derived from Internal clock
	?LINE	305
	MOV	R12,0F0BCh
	JNB	R12.2,_7
; main.c    306		{
; main.c    307			//Normal startup state during boot and the clock
; main.c    308			//has to be in the next step configured on the external crystal
; main.c    309			//use XTAL/VCO, count XTAL clock
; main.c    310	
; main.c    311			SCS_StartXtalOsc(1);	   // Starts the crystal oscillator
	?LINE	311
	MOV	R12,#01h
	CALLS	SEG _SCS_StartXtalOsc,_SCS_StartXtalOsc
; main.c    312			SCS_SwitchSystemClock(1);  // System clock is increased to target speed (80/66 MHz)
	?LINE	312
	MOV	R12,#01h
	CALLS	SEG _SCS_SwitchSystemClock,_SCS_SwitchSystemClock
; main.c    313	
; main.c    314		}
	?LINE	314
	RETS
_7:
; main.c    315	
; main.c    316		else  // fR derived from external crystal clock
; main.c    317		{
; main.c    318			if ((SCU_PLLSTAT & 0x1009) == 0x1009)  // fR derived from external crystal clock + VCO is locked
	?LINE	318
	MOV	R12,0F0BCh
	AND	R12,#01009h
	CMP	R12,#01009h
	JMPR	cc_NE,_8
; main.c    319			{
; main.c    320				//usually after an application reset where clock need not be configured again.
; main.c    321				//check K2/P/N values and decide whether these values have to be adapted based on application needs.
; main.c    322				NOP();
	?LINE	322
	NOP
; main.c    323				//usually the PLL losss of Lock TRAP schould be enabled here.
; main.c    324			} else	//fR derived from external crystal clock + VCO is not locked
	?LINE	324
	JMPR	cc_UC,_9
_8:
; main.c    325	
; main.c    326			{
; main.c    327				//estimate the K1 value and the current frequency
; main.c    328				//reduce K2/P/N values in steps so that the frequency
; main.c    329				//jumps is limited to 20MHz or factor of 5 whichever is minimum
; main.c    330				NOP();
	?LINE	330
	NOP
; main.c    331			}
	?LINE	331
_9:
; main.c    332		}
	?LINE	332
_10:
; main.c    333	
; main.c    334	}  //  End of function MAIN_vChangeFreq
	?LINE	334
	RETS
_MAIN_vChangeFreq	ENDP
	?SYMB	'',$,17,334
; main.c    335	
; main.c    336	//****************************************************************************
; main.c    337	// @Function      void main(void)
; main.c    338	//
; main.c    339	//----------------------------------------------------------------------------
; main.c    340	// @Description   This is the main function.
; main.c    341	//
; main.c    342	//----------------------------------------------------------------------------
; main.c    343	// @Returnvalue   None
; main.c    344	//
; main.c    345	//----------------------------------------------------------------------------
; main.c    346	// @Parameters    None
; main.c    347	//
; main.c    348	//----------------------------------------------------------------------------
; main.c    349	// @Date          29.09.2021
; main.c    350	//
; main.c    351	//****************************************************************************
; main.c    352	
; main.c    353	// USER CODE BEGIN (Main,1)
; main.c    354	
; main.c    355	// USER CODE END
; main.c    356	
; main.c    357	void main(void) {
	?LINE	357
	PUBLIC	_main
	?SYMB	'main',_main,37,1
	?SYMB	'',357,8,34
_main	PROC	FAR
	?SYMB	'',00H,95,0
	SUB	R0,#04h
	?SYMB	'',$,96,4
; Locals:
;     raw = offset 0
; 
; Statics:
; 
; CSEs:
; 
; main.c    358		// USER CODE BEGIN (Main,2)
; main.c    359	
; main.c    360		// USER CODE END
; main.c    361	
; main.c    362		MAIN_vInit();
	?LINE	362
	CALLS	SEG _MAIN_vInit,_MAIN_vInit
; main.c    363	
; main.c    364		// USER CODE BEGIN (Main,3)
; main.c    365		// einmalige Funktionen zum herstellen des Betriebszustandes
; main.c    366		// generierung der Tabelle vor dem Starten der Timer
; main.c    367		generateTable();
	?LINE	367
	CALLS	SEG _generateTable,_generateTable
; main.c    368		// Konfiguriert den ADC
; main.c    369		ADC0_vInit();
	?LINE	369
	CALLS	SEG _ADC0_vInit,_ADC0_vInit
; main.c    370		// Starten des ADCs (externer Trigger, interrupt einschalten, Refill bit?, Kanal des ADCs)
; main.c    371		ADC0_vStartSeq0ReqChNum(0, 0, 1, 6);
	?LINE	371
	MOV	R12,#00h
	MOV	R13,#00h
	MOV	R14,#01h
	MOV	R15,#06h
	CALLS	SEG _ADC0_vStartSeq0ReqChNum,_ADC0_vStartSeq0ReqChNum
; main.c    372		// Timer 12 von CCU63 starten
; main.c    373		CCU63_vStartTmr(CCU63_TIMER_12);
	?LINE	373
	MOV	R12,#0EBA6h
	MOV	R13,[R12]
	BSET	R13.1
	MOV	[R12],R13
; main.c    374		// Timer 12 von CCU62 starten
; main.c    375		CCU62_vStartTmr(CCU62_TIMER_12);
	?LINE	375
	MOV	R12,#0EB26h
	MOV	R13,[R12]
	BSET	R13.1
	MOV	[R12],R13
; main.c    376		// Timer 6 von GPT2 starten
; main.c    377		GPT2_vStartTmr(GPT2_TIMER_6);
	?LINE	377
	MOV	R12,#0FF48h
	MOV	R13,[R12]
	BFLDL	R13,#040h,#040h
	MOV	[R12],R13
; main.c    378		// USER CODE END
; main.c    379	
; main.c    380		while (1) {
	?LINE	380
	JMPA+	cc_UC,_48
_30:
; main.c    381			// USER CODE BEGIN (Main,4)
; main.c    382	
; main.c    383			// one rampIndex step = 8ms, 250 steps = 2s
; main.c    384			// Rechtslauf zu Beginn festlegen
; main.c    385			if (rampIndex == 0) {
	?LINE	385
	MOV	R12,_rampIndex
	JMPR	cc_NZ,_31
; main.c    386				setPhaseChange(clockwise);
	?LINE	386
	MOV	R12,#00h
	CALLS	SEG _setPhaseChange,_setPhaseChange
; main.c    387			}
	?LINE	387
_31:
; main.c    388	
; main.c    389			// Drehzahlregelung mit Potentiometer
; main.c    390			if (rampIndex > 5250) {
	?LINE	390
	MOV	R12,_rampIndex
	CMP	R12,#01482h
	JMPR	cc_ULE,_32
; main.c    391				// lokale Variable für den ADC Messwert
; main.c    392				unsigned long raw;
	?SYMB	'',$,9,392
	?SYMB	'raw',1,98,7
	?SYMB	'-4',$,101,1
; main.c    393				// lesen des ADC Werts
; main.c    394				raw = ADC0_uwGetResultData(RESULT_REG_0);
	?LINE	394
	MOV	R12,0E0B0h
	JNB	R12.12,_49
	JMPR	cc_UC,_50
_50:
	MOV	R12,0E050h
	AND	R12,#03FFFh
	SHR	R12,#02h
	JMPR	cc_UC,_51
_49:
	MOV	R12,#00h
_51:
	MOV	R13,#00h
	MOV	[R0],R12
	MOV	[R0+#02H],R13
; main.c    395				// 4096 ist Auflösung des ADC, links = 0, rechts = 4096
; main.c    396				// Normierung des ADC Messwerts auf 25 Hz mechanisch
; main.c    397				frequency = controller((25 * raw) / 4096);
	?LINE	397
	MOV	R4,[R0]
	MOV	R5,[R0+#02H]
	MOV	R10,#019h
	MOV	R11,#00h
	CALLS	SEG __mul,__mul
	MOV	R12,R5
	SHR	R4,#0Ch
	SHR	R5,#0Ch
	SHL	R12,#04h
	OR	R4,R12
	MOV	R12,R4
	CALLS	SEG _controller,_controller
	MOV	_frequency,R4
; main.c    398				// schreiben des CCU62 Schattenregisters
; main.c    399				CCU62_vSetTmrPeriod(CCU62_TIMER_12, calculateMotorFrequency(frequency));
	?LINE	399
	MOV	R12,_frequency
	CALLS	SEG _calculateMotorFrequency,_calculateMotorFrequency
	MOV	0EB12h,R4
; main.c    400				// Übernahme des Schattenregisters erlauben
; main.c    401				CCU62_vEnableShadowTransfer(CCU62_TIMER_12);
	?LINE	401
	MOV	R12,#0EB26h
	MOV	R13,[R12]
	BSET	R13.6
	MOV	[R12],R13
; main.c    402			}
	?SYMB	'',$,102,1
	?SYMB	'',$,15,402
	?LINE	402
_32:
; main.c    403	
; main.c    404			// steigende Rampe Rechtslauf
; main.c    405			if (rampIndex < 750) {
	?LINE	405
	MOV	R12,_rampIndex
	CMP	R12,#02EEh
	JMPR	cc_UGE,_33
; main.c    406				frequency = (rampIndex / 15);
	?LINE	406
	MOV	R12,_rampIndex
	MOV	R13,#0Fh
	MOV	MDL,R12
	DIVU	R13
	MOV	R12,MDL
	MOV	_frequency,R12
; main.c    407				CCU62_vSetTmrPeriod(CCU62_TIMER_12, calculateMotorFrequency(frequency));
	?LINE	407
	MOV	R12,_frequency
	CALLS	SEG _calculateMotorFrequency,_calculateMotorFrequency
	MOV	0EB12h,R4
; main.c    408				CCU62_vEnableShadowTransfer(CCU62_TIMER_12);
	?LINE	408
	MOV	R12,#0EB26h
	MOV	R13,[R12]
	BSET	R13.6
	MOV	[R12],R13
; main.c    409				IO_vTogglePin(LED_DBG);
	?LINE	409
	MOV	R12,#0101h
	MOV	0E9E0h,R12
; main.c    410			}
	?LINE	410
_33:
; main.c    411	
; main.c    412			// Geschwindigkeit halten
; main.c    413			if (rampIndex < 1500 && rampIndex > 750) {
	?LINE	413
	MOV	R12,_rampIndex
	CMP	R12,#05DCh
	JMPR	cc_UGE,_34
	MOV	R12,_rampIndex
	CMP	R12,#02EEh
	JMPR	cc_ULE,_35
; main.c    414				frequency = 50;
	?LINE	414
	MOV	R12,#032h
	MOV	_frequency,R12
; main.c    415				CCU62_vSetTmrPeriod(CCU62_TIMER_12, calculateMotorFrequency(frequency));
	?LINE	415
	MOV	R12,_frequency
	CALLS	SEG _calculateMotorFrequency,_calculateMotorFrequency
	MOV	0EB12h,R4
; main.c    416				CCU62_vEnableShadowTransfer(CCU62_TIMER_12);
	?LINE	416
	MOV	R12,#0EB26h
	MOV	R13,[R12]
	BSET	R13.6
	MOV	[R12],R13
; main.c    417			}
	?LINE	417
_34:
_35:
; main.c    418	
; main.c    419			// fallende Rampe Rechtslauf
; main.c    420			if (rampIndex < 2250 && rampIndex > 1500) {
	?LINE	420
	MOV	R12,_rampIndex
	CMP	R12,#08CAh
	JMPR	cc_UGE,_36
	MOV	R12,_rampIndex
	CMP	R12,#05DCh
	JMPR	cc_ULE,_37
; main.c    421				frequency = (2250 - rampIndex) / 15;
	?LINE	421
	MOV	R12,#08CAh
	SUB	R12,_rampIndex
	MOV	R13,#0Fh
	MOV	MDL,R12
	DIVU	R13
	MOV	R12,MDL
	MOV	_frequency,R12
; main.c    422				CCU62_vSetTmrPeriod(CCU62_TIMER_12, calculateMotorFrequency(frequency));
	?LINE	422
	MOV	R12,_frequency
	CALLS	SEG _calculateMotorFrequency,_calculateMotorFrequency
	MOV	0EB12h,R4
; main.c    423				CCU62_vEnableShadowTransfer(CCU62_TIMER_12);
	?LINE	423
	MOV	R12,#0EB26h
	MOV	R13,[R12]
	BSET	R13.6
	MOV	[R12],R13
; main.c    424			}
	?LINE	424
_36:
_37:
; main.c    425	
; main.c    426			// Phasen tauschen um Drehrichtung zu ändern
; main.c    427			if (rampIndex == 2250) {
	?LINE	427
	MOV	R12,_rampIndex
	CMP	R12,#08CAh
	JMPR	cc_NE,_38
; main.c    428				setPhaseChange(counterclockwise);
	?LINE	428
	MOV	R12,#01h
	CALLS	SEG _setPhaseChange,_setPhaseChange
; main.c    429			}
	?LINE	429
_38:
; main.c    430	
; main.c    431			// steigende Rampe Linkslauf
; main.c    432			if (rampIndex < 3000 && rampIndex > 2250) {
	?LINE	432
	MOV	R12,_rampIndex
	CMP	R12,#0BB8h
	JMPR	cc_UGE,_39
	MOV	R12,_rampIndex
	CMP	R12,#08CAh
	JMPR	cc_ULE,_40
; main.c    433				frequency = (rampIndex - 2250) / 15;
	?LINE	433
	MOV	R12,_rampIndex
	SUB	R12,#08CAh
	MOV	R13,#0Fh
	MOV	MDL,R12
	DIVU	R13
	MOV	R12,MDL
	MOV	_frequency,R12
; main.c    434				CCU62_vSetTmrPeriod(CCU62_TIMER_12, calculateMotorFrequency(frequency));
	?LINE	434
	MOV	R12,_frequency
	CALLS	SEG _calculateMotorFrequency,_calculateMotorFrequency
	MOV	0EB12h,R4
; main.c    435				CCU62_vEnableShadowTransfer(CCU62_TIMER_12);
	?LINE	435
	MOV	R12,#0EB26h
	MOV	R13,[R12]
	BSET	R13.6
	MOV	[R12],R13
; main.c    436			}
	?LINE	436
_39:
_40:
; main.c    437	
; main.c    438			// Geschwindigkeit halten Linkslauf
; main.c    439			if (rampIndex < 3750 && rampIndex > 3000) {
	?LINE	439
	MOV	R12,_rampIndex
	CMP	R12,#0EA6h
	JMPR	cc_UGE,_41
	MOV	R12,_rampIndex
	CMP	R12,#0BB8h
	JMPR	cc_ULE,_42
; main.c    440				frequency = 50;
	?LINE	440
	MOV	R12,#032h
	MOV	_frequency,R12
; main.c    441				CCU62_vSetTmrPeriod(CCU62_TIMER_12, calculateMotorFrequency(frequency));
	?LINE	441
	MOV	R12,_frequency
	CALLS	SEG _calculateMotorFrequency,_calculateMotorFrequency
	MOV	0EB12h,R4
; main.c    442				CCU62_vEnableShadowTransfer(CCU62_TIMER_12);
	?LINE	442
	MOV	R12,#0EB26h
	MOV	R13,[R12]
	BSET	R13.6
	MOV	[R12],R13
; main.c    443			}
	?LINE	443
_41:
_42:
; main.c    444	
; main.c    445			// Fallende Rampe linkslauf
; main.c    446			if (rampIndex < 4500 && rampIndex > 3750) {
	?LINE	446
	MOV	R12,_rampIndex
	CMP	R12,#01194h
	JMPR	cc_UGE,_43
	MOV	R12,_rampIndex
	CMP	R12,#0EA6h
	JMPR	cc_ULE,_44
; main.c    447				frequency = (4500 - rampIndex) / 15;
	?LINE	447
	MOV	R12,#01194h
	SUB	R12,_rampIndex
	MOV	R13,#0Fh
	MOV	MDL,R12
	DIVU	R13
	MOV	R12,MDL
	MOV	_frequency,R12
; main.c    448				CCU62_vSetTmrPeriod(CCU62_TIMER_12, calculateMotorFrequency(frequency));
	?LINE	448
	MOV	R12,_frequency
	CALLS	SEG _calculateMotorFrequency,_calculateMotorFrequency
	MOV	0EB12h,R4
; main.c    449				CCU62_vEnableShadowTransfer(CCU62_TIMER_12);
	?LINE	449
	MOV	R12,#0EB26h
	MOV	R13,[R12]
	BSET	R13.6
	MOV	[R12],R13
; main.c    450			}
	?LINE	450
_43:
_44:
; main.c    451	
; main.c    452			// Gleichstrombremsen !!! anpassen des CCU62 rampIndex nicht vergessen !!!
; main.c    453			if (rampIndex < 5250 && rampIndex > 4500) {
	?LINE	453
	MOV	R12,_rampIndex
	CMP	R12,#01482h
	JMPR	cc_UGE,_45
	MOV	R12,_rampIndex
	CMP	R12,#01194h
	JMPR	cc_ULE,_46
; main.c    454				frequency = 50;
	?LINE	454
	MOV	R12,#032h
	MOV	_frequency,R12
; main.c    455				CCU62_vSetTmrPeriod(CCU62_TIMER_12, calculateMotorFrequency(frequency));
	?LINE	455
	MOV	R12,_frequency
	CALLS	SEG _calculateMotorFrequency,_calculateMotorFrequency
	MOV	0EB12h,R4
; main.c    456				CCU62_vEnableShadowTransfer(CCU62_TIMER_12);
	?LINE	456
	MOV	R12,#0EB26h
	MOV	R13,[R12]
	BSET	R13.6
	MOV	[R12],R13
; main.c    457			}
	?LINE	457
_45:
_46:
; main.c    458	
; main.c    459			// Frequenz vor der Drehzzahlregelung auf 0 setzen
; main.c    460			if (rampIndex == 5250) {
	?LINE	460
	MOV	R12,_rampIndex
	CMP	R12,#01482h
	JMPR	cc_NE,_47
; main.c    461				frequency = 0;
	?LINE	461
	MOV	_frequency,ZEROS
; main.c    462				CCU62_vSetTmrPeriod(CCU62_TIMER_12, calculateMotorFrequency(frequency));
	?LINE	462
	MOV	R12,_frequency
	CALLS	SEG _calculateMotorFrequency,_calculateMotorFrequency
	MOV	0EB12h,R4
; main.c    463				CCU62_vEnableShadowTransfer(CCU62_TIMER_12);
	?LINE	463
	MOV	R12,#0EB26h
	MOV	R13,[R12]
	BSET	R13.6
	MOV	[R12],R13
; main.c    464			}
	?LINE	464
_47:
	?LINE	380
_48:
	JMPA+	cc_UC,_30
; main.c    465	
; main.c    466			// USER CODE END
; main.c    467		}
; main.c    468	
; main.c    469	}  //  End of function main
	?LINE	469
	ADD	R0,#04h
	?SYMB	'',$,96,0
	RETS
_main	ENDP
	?SYMB	'',$,17,469
; main.c    470	
; main.c    471	// USER CODE BEGIN (MAIN_General,10)
; main.c    472	// Funktion zur Generierung der Wertetabelle
; main.c    473	void generateTable() {
	?LINE	473
	PUBLIC	_generateTable
	?SYMB	'generateTable',_generateTable,37,1
	?SYMB	'',473,8,34
_generateTable	PROC	FAR
	?SYMB	'',00H,95,0
	SUB	R0,#0Ah
	?SYMB	'',$,96,10
; Locals:
;     i = offset 0
;     stepSize = offset 2
; 
; Statics:
; 
; CSEs:
; 
; main.c    474		double stepSize = (2 * pi) / (ARRAY_SIZE);
	?SYMB	'stepSize',2,98,11
	?SYMB	'-8',$,101,2
	?LINE	474
	MOV	R4,_pi
	MOV	R5,(_pi+2)
	MOV	R10,#04000h
	MOV	R11,#00h
	CALLS	SEG __mlf4r,__mlf4r
	MOV	R10,#04496h
	MOV	R11,#00h
	CALLS	SEG __dvf4r,__dvf4r
	CALLS	SEG __cff48r,__cff48r
	?SYMB	'',$,96,18
	MOV	R4,R0
	ADD	R4,#0Ah
	CALLS	SEG __store8n,__store8n
	ADD	R0,#08h
	?SYMB	'',$,96,10
; main.c    475		int i;
	?SYMB	'i',1,98,16
	?SYMB	'-a',$,101,1
; main.c    476		for (i = 0; i < ARRAY_SIZE; i++) {
	?LINE	476
	MOV	R12,#00h
	MOV	[R0],R12
	JMPR	cc_UC,_57
_56:
; main.c    477			table[i] = (int)((double)((CCU63_T12PR - 140) / 2) * sin(stepSize * i));
	?LINE	477
	SUB	R0,#08h
	?SYMB	'',$,96,18
	MOV	R4,#0Ah
	ADD	R4,R0
	CALLS	SEG __load8n,__load8n
	?SYMB	'',$,96,26
	MOV	R11,[R0+#010H]
	MOV	R4,R11
	MOV	R12,R10
	CALLS	SEG __cif28r,__cif28r
	?SYMB	'',$,96,34
	MOV	R11,R10
	MOV	R10,R12
	CALLS	SEG __mlf8r,__mlf8r
	ADD	R0,#08h
	?SYMB	'',$,96,26
	CALLS	SEG _sin,_sin
	ADD	R0,#08h
	?SYMB	'',$,96,18
	MOV	R11,R4
	MOV	R10,0EB92h
	SUB	R10,#08Ch
	SHR	R10,#01h
	MOV	R4,R10
	CALLS	SEG __cuf28r,__cuf28r
	?SYMB	'',$,96,26
	CALLS	SEG __mlf8r,__mlf8r
	CALLS	SEG __cfi82r,__cfi82r
	ADD	R0,#010h
	?SYMB	'',$,96,10
	MOV	R12,[R0]
	SHL	R12,#01h
	MOV	[R12+#_table],R4
	?LINE	476
	MOV	R12,[R0]
	ADD	R12,#01h
	MOV	[R0],R12
_57:
	MOV	R12,[R0]
	CMP	R12,#04B0h
	JMPR	cc_ULT,_56
; main.c    478		}
; main.c    479	}
	?SYMB	'',$,102,1
	?SYMB	'',$,102,2
	?LINE	479
	ADD	R0,#0Ah
	?SYMB	'',$,96,0
	RETS
_generateTable	ENDP
	?SYMB	'',$,17,479
; main.c    480	
; main.c    481	// berechnet den Period Value in Abhängigkeit der Frequenz, Frequenzen < 2 Hz = 1Hz
; main.c    482	unsigned int calculateMotorFrequency(unsigned int _frequency) {
	?LINE	482
	PUBLIC	_calculateMotorFrequency
	?SYMB	'calculateMotorFrequency',_calculateMotorFrequency,37,18
	?SYMB	'',482,8,34
_calculateMotorFrequency	PROC	FAR
	?SYMB	'',00H,95,0
	MOV	[-R0],R12
	?SYMB	'',$,96,2
; Locals:
;     _frequency = offset 0
; 
; Statics:
; 
; CSEs:
; 
	?SYMB	'_frequency',1,99,18
	?SYMB	'-2',$,101,1
; main.c    483		if (_frequency < 2) {
	?LINE	483
	MOV	R12,[R0]
	CMP	R12,#02h
	JMPR	cc_UGE,_62
; main.c    484			frequency = 1;
	?LINE	484
	MOV	R12,#01h
	MOV	_frequency,R12
; main.c    485			return (0xD903);
	?LINE	485
	MOV	R4,#0D903h
	JMPR	cc_UC,_63
; main.c    486		} else {
	?LINE	486
_62:
; main.c    487			//float Operation wird nicht ersetzt da Datentyp größer als long verwendet werden müsste: benötigter Wertebereich von >10^22
; main.c    488			return (1 / ((float)_frequency * (float)ARRAY_SIZE * 0.000000015));	 
	?LINE	488
	MOV	R4,[R0]
	CALLS	SEG __cuf24r,__cuf24r
	MOV	R10,#04496h
	MOV	R11,#00h
	CALLS	SEG __mlf4r,__mlf4r
	CALLS	SEG __cff48r,__cff48r
	?SYMB	'',$,96,10
	MOV	R11,R10
	MOV	R4,#_58
	CALLS	SEG __load8n,__load8n
	?SYMB	'',$,96,18
	CALLS	SEG __mlf8r,__mlf8r
	MOV	R11,R10
	MOV	R4,#_59
	CALLS	SEG __load8n,__load8n
	?SYMB	'',$,96,26
	CALLS	SEG __dvf8r,__dvf8r
	CALLS	SEG __cfu82r,__cfu82r
	ADD	R0,#018h
	?SYMB	'',$,96,2
; main.c    489		}
; main.c    490	}
	?LINE	490
_63:
	?SYMB	'',$,102,1
	ADD	R0,#02h
	?SYMB	'',$,96,0
	RETS
_calculateMotorFrequency	ENDP
	?SYMB	'',$,17,490
; main.c    491	
; main.c    492	// Funktion für die Phasendrehung
; main.c    493	void setPhaseChange(int dir) {
	?LINE	493
	PUBLIC	_setPhaseChange
	?SYMB	'setPhaseChange',_setPhaseChange,37,1
	?SYMB	'',493,8,34
_setPhaseChange	PROC	FAR
	?SYMB	'',00H,95,0
	MOV	[-R0],R12
	?SYMB	'',$,96,2
; Locals:
;     dir = offset 0
; 
; Statics:
; 
; CSEs:
; 
	?SYMB	'dir',1,99,16
	?SYMB	'-2',$,101,1
; main.c    494		if (dir == clockwise) {
	?LINE	494
	MOV	R12,[R0]
	JMPR	cc_NZ,_66
; main.c    495			OFFSET_L1 = 0;
	?LINE	495
	MOV	_OFFSET_L1,ZEROS
; main.c    496			OFFSET_L2 = ARRAY_SIZE / 3;
	?LINE	496
	MOV	R12,#0190h
	MOV	_OFFSET_L2,R12
; main.c    497			OFFSET_L3 = (2 * ARRAY_SIZE) / 3;
	?LINE	497
	MOV	R12,#0320h
	MOV	_OFFSET_L3,R12
; main.c    498		}
	?LINE	498
_66:
; main.c    499		if (dir == counterclockwise) {
	?LINE	499
	MOV	R12,[R0]
	CMP	R12,#01h
	JMPR	cc_NE,_67
; main.c    500			OFFSET_L1 = 0;
	?LINE	500
	MOV	_OFFSET_L1,ZEROS
; main.c    501			OFFSET_L2 = (2 * ARRAY_SIZE) / 3;
	?LINE	501
	MOV	R12,#0320h
	MOV	_OFFSET_L2,R12
; main.c    502			OFFSET_L3 = ARRAY_SIZE / 3;
	?LINE	502
	MOV	R12,#0190h
	MOV	_OFFSET_L3,R12
; main.c    503		}
	?LINE	503
_67:
; main.c    504	}
	?SYMB	'',$,102,1
	?LINE	504
	ADD	R0,#02h
	?SYMB	'',$,96,0
	RETS
_setPhaseChange	ENDP
	?SYMB	'',$,17,504
; main.c    505	
; main.c    506	// PI Regler
; main.c    507	unsigned int controller(int input) {
	?LINE	507
	PUBLIC	_controller
	?SYMB	'controller',_controller,37,18
	?SYMB	'',507,8,34
_controller	PROC	FAR
	?SYMB	'',00H,95,0
	MOV	[-R0],R12
	?SYMB	'',$,96,2
	SUB	R0,#04h
	?SYMB	'',$,96,6
; Locals:
;     manipulated_variable = offset 0
;     controller_error = offset 2
;     input = offset 4
; 
; Statics:
; 
; CSEs:
; 
	?SYMB	'input',3,99,16
	?SYMB	'-2',$,101,3
; main.c    508		//Regelabweichung = mech Drehzahldifferenz
; main.c    509		int controller_error = input - velocity;  // velocity =^ output/ feedback
	?SYMB	'controller_error',2,98,16
	?SYMB	'-4',$,101,2
	?LINE	509
	MOV	R10,_velocity
	MOV	R11,(_velocity+2)
	MOV	R4,[R0+#04H]
	CALLS	SEG __cif24r,__cif24r
	CALLS	SEG __sbf4r,__sbf4r
	CALLS	SEG __cfi42r,__cfi42r
	MOV	[R0+#02H],R4
; main.c    510		//P-Regler
; main.c    511		int manipulated_variable = controller_error * K_p;
	?SYMB	'manipulated_variable',1,98,16
	?SYMB	'-6',$,101,1
	?LINE	511
	MOV	R4,_K_p
	MOV	R5,(_K_p+2)
	MOV	R12,R4
	MOV	R4,[R0+#02H]
	MOV	R13,R5
	CALLS	SEG __cif24r,__cif24r
	MOV	R11,R13
	MOV	R10,R12
	CALLS	SEG __mlf4r,__mlf4r
	CALLS	SEG __cfi42r,__cfi42r
	MOV	[R0],R4
; main.c    512		//I-Regler
; main.c    513		integral_sum = integral_sum + controller_error;	 //so gehts auch: integral_sum += controller_error
	?LINE	513
	MOV	R12,[R0+#02H]
	ADD	R12,_integral_sum
	MOV	_integral_sum,R12
; main.c    514		
; main.c    515		//P- + I-Regler
; main.c    516		manipulated_variable = manipulated_variable + K_i * integral_sum;
	?LINE	516
	MOV	R4,_K_i
	MOV	R5,(_K_i+2)
	MOV	R12,R4
	MOV	R4,_integral_sum
	MOV	R13,R5
	CALLS	SEG __cif24r,__cif24r
	MOV	R11,R13
	MOV	R10,R12
	CALLS	SEG __mlf4r,__mlf4r
	MOV	R12,R4
	MOV	R4,[R0]
	MOV	R13,R5
	CALLS	SEG __cif24r,__cif24r
	MOV	R11,R13
	MOV	R10,R12
	CALLS	SEG __adf4r,__adf4r
	CALLS	SEG __cfi42r,__cfi42r
	MOV	[R0],R4
; main.c    517		//Vorsteuerung
; main.c    518		manipulated_variable += input * 2;
	?LINE	518
	MOV	R12,[R0+#04H]
	SHL	R12,#01h
	MOV	R13,[R0]
	ADD	R13,R12
	MOV	[R0],R13
; main.c    519		//Stellgrößenbegrenzung
; main.c    520		if (manipulated_variable > 55) {
	?LINE	520
	MOV	R12,[R0]
	CMP	R12,#037h
	JMPR	cc_SLE,_71
; main.c    521			manipulated_variable = 55;
	?LINE	521
	MOV	R12,#037h
	MOV	[R0],R12
; main.c    522		} else if (manipulated_variable < 0) {
	?LINE	522
	JMPR	cc_UC,_73
_71:
	MOV	R12,[R0]
	CMP	R12,#00h
	JMPR	cc_SGE,_72
; main.c    523			manipulated_variable = 1;
	?LINE	523
	MOV	R12,#01h
	MOV	[R0],R12
; main.c    524		}
	?LINE	524
_72:
; main.c    525		return (manipulated_variable);
	?LINE	525
_73:
	MOV	R4,[R0]
; main.c    526	}
	?SYMB	'',$,102,1
	?SYMB	'',$,102,2
	?SYMB	'',$,102,3
	?LINE	526
	ADD	R0,#06h
	?SYMB	'',$,96,0
	RETS
_controller	ENDP
	?SYMB	'',$,17,526
; main.c    527	
; main.c    528	// USER CODE END
MAIN_4_PR	ENDS

MAIN_5_NB	SECTION	LDAT WORD PUBLIC 'CNEAR'
MAIN_5_NB_ENTRY	LABEL	BYTE
_table	LABEL	WORD
	DS	2400
	PUBLIC	_table
	?SYMB	'',01210010H,5,288
	?SYMB	'',16,47,289
	?SYMB	'',0,30,0
	?SYMB	'',1199,49,0
	?SYMB	'table',_table,22,288
_integral_sum	LABEL	WORD
	DS	2
	PUBLIC	_integral_sum
	?SYMB	'integral_sum',_integral_sum,22,16
_velocity	LABEL	WORD
	DS	4
	PUBLIC	_velocity
	?SYMB	'velocity',_velocity,22,10
_rampIndex	LABEL	WORD
	DS	2
	PUBLIC	_rampIndex
	?SYMB	'rampIndex',_rampIndex,22,18
_index	LABEL	WORD
	DS	2
	PUBLIC	_index
	?SYMB	'index',_index,22,18
_OFFSET_L1	LABEL	WORD
	DS	2
	PUBLIC	_OFFSET_L1
	?SYMB	'OFFSET_L1',_OFFSET_L1,22,18
_OFFSET_L3	LABEL	WORD
	DS	2
	PUBLIC	_OFFSET_L3
	?SYMB	'OFFSET_L3',_OFFSET_L3,22,18
_OFFSET_L2	LABEL	WORD
	DS	2
	PUBLIC	_OFFSET_L2
	?SYMB	'OFFSET_L2',_OFFSET_L2,22,18
MAIN_5_NB	ENDS

MAIN_6_CO	SECTION	LDAT WORD PUBLIC 'CROM'
_58	LABEL	WORD
	DW	03E50h,01B2Bh,029A4h,0692Bh
_59	LABEL	WORD
	DW	03FF0h,00h,00h,00h
MAIN_6_CO	ENDS

C166_US	SECTION	LDAT WORD GLBUSRSTACK 'CUSTACK'
	DS	76
C166_US	ENDS

C166_INIT	SECTION	PDAT WORD GLOBAL 'CINITROM'
	DW	06h
	DPPTR	MAIN_ID_NB_ENTRY,MAIN_IR_NB_ENTRY
	DW	06h
C166_INIT	ENDS

C166_BSS	SECTION	PDAT WORD GLOBAL 'CINITROM'
	DW	05h,MAIN_5_NB_ENTRY,0970h
C166_BSS	ENDS

$FLOAT(ANSI)
	EXTERN	_ADC0_vStartSeq0ReqChNum:FAR
	EXTERN	_CCU62_vInit:FAR
	EXTERN	_CCU63_vInit:FAR
	EXTERN	_sin:FAR
	EXTERN	_SCS_SwitchToHighPrecBandgap:FAR
	EXTERN	_SCS_StartXtalOsc:FAR
	EXTERN	_IO_vInit:FAR
	EXTERN	_GPT2_vInit:FAR
	EXTERN	_GPT1_vInit:FAR
	EXTERN	_SCS_SwitchSystemClock:FAR
	EXTERN	_ADC0_vInit:FAR
	EXTERN	__mul:FAR
	EXTERN	__mlf4r:FAR
	EXTERN	__dvf4r:FAR
	EXTERN	__cff48r:FAR
	EXTERN	__store8n:FAR
	EXTERN	__load8n:FAR
	EXTERN	__cif28r:FAR
	EXTERN	__mlf8r:FAR
	EXTERN	__cuf28r:FAR
	EXTERN	__cfi82r:FAR
	EXTERN	__cuf24r:FAR
	EXTERN	__dvf8r:FAR
	EXTERN	__cfu82r:FAR
	EXTERN	__cif24r:FAR
	EXTERN	__sbf4r:FAR
	EXTERN	__cfi42r:FAR
	EXTERN	__adf4r:FAR
	EXTERN	__CSTART:FAR
	REGDEF	R0-R15
	END
